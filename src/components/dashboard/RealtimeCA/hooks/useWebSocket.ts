import { useState, useEffect, useRef, useCallback } from 'react';
import { TokenManager } from "~src/services/token.service";
import { WS_CONFIG, WS_MESSAGE_TYPES } from '../constants';
import { validateCAEvent } from '../utils';
import type { 
  ConnectionStatus, 
  CAEvent, 
  RealtimeCASettings,
  SubscriptionConfig,
  WebSocketMessage 
} from '~src/types/realtime-ca.types';

interface UseWebSocketOptions {
  onMessage: (event: CAEvent) => void;
  settings: RealtimeCASettings;
}

interface UseWebSocketReturn {
  connectionStatus: ConnectionStatus;
  isConnected: boolean;
  connect: () => void;
  disconnect: () => void;
  subscribe: (config?: SubscriptionConfig) => void;
  unsubscribe: () => void;
  updateSubscription: (config: SubscriptionConfig) => void;
  reconnectAttempts: number;
}

export function useWebSocket({ onMessage, settings }: UseWebSocketOptions): UseWebSocketReturn {
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>('disconnected');
  const [reconnectAttempts, setReconnectAttempts] = useState(0);

  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const heartbeatIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const heartbeatTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const isManualDisconnectRef = useRef(false);
  const connectFnRef = useRef<((forceConnect?: boolean) => Promise<void>) | null>(null);

  const isConnected = connectionStatus === 'connected';

  // ÁßªÈô§ÊâÄÊúâÊ®°ÊãüÊï∞ÊçÆÁõ∏ÂÖ≥‰ª£Á†Å
  
  // Ê∏ÖÁêÜÂÆöÊó∂Âô®
  const clearTimers = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current);
      heartbeatIntervalRef.current = null;
    }
    if (heartbeatTimeoutRef.current) {
      clearTimeout(heartbeatTimeoutRef.current);
      heartbeatTimeoutRef.current = null;
    }
  }, []);
  
  // ÂèëÈÄÅÊ∂àÊÅØ
  const sendMessage = useCallback((message: any): boolean => {
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
      console.warn('WebSocket not connected, cannot send message:', message);
      return false;
    }
    
    try {
      wsRef.current.send(JSON.stringify(message));
      console.log('üì§ WebSocket message sent:', message.action || message.type);
      return true;
    } catch (error) {
      console.error('‚ùå Failed to send WebSocket message:', error);
      return false;
    }
  }, []);
  
  // ÂºÄÂßãÂøÉË∑≥
  const startHeartbeat = useCallback(() => {
    clearTimers();
    
    heartbeatIntervalRef.current = setInterval(() => {
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        sendMessage({ action: WS_MESSAGE_TYPES.PING });
        
        // ËÆæÁΩÆÂøÉË∑≥Ë∂ÖÊó∂
        heartbeatTimeoutRef.current = setTimeout(() => {
          console.error('‚ùå Heartbeat timeout, closing connection');
          wsRef.current?.close();
        }, WS_CONFIG.PONG_TIMEOUT);
      }
    }, WS_CONFIG.HEARTBEAT_INTERVAL);
  }, [sendMessage, clearTimers]);
  
  // Â§ÑÁêÜÂøÉË∑≥ÂìçÂ∫î
  const handlePong = useCallback(() => {
    if (heartbeatTimeoutRef.current) {
      clearTimeout(heartbeatTimeoutRef.current);
      heartbeatTimeoutRef.current = null;
    }
  }, []);
  
  // Â§ÑÁêÜWebSocketÊ∂àÊÅØ
  const handleMessage = useCallback((event: MessageEvent) => {
    try {
      const message: WebSocketMessage = JSON.parse(event.data);
      console.log('üì® WebSocket message received:', message.type);
      
      switch (message.type) {
        case WS_MESSAGE_TYPES.SUBSCRIBE_SUCCESS:
          console.log('‚úÖ Subscription successful:', message);
          break;
          
        case WS_MESSAGE_TYPES.SUBSCRIBE_ERROR:
          console.error('‚ùå Subscription failed:', message.error);
          break;
          
        case WS_MESSAGE_TYPES.REALTIME_CA:
          if (validateCAEvent(message)) {
            onMessage(message as CAEvent);
          } else {
            console.warn('‚ö†Ô∏è Invalid CA event received:', message);
          }
          break;
          
        case WS_MESSAGE_TYPES.PONG:
          handlePong();
          break;
          
        case WS_MESSAGE_TYPES.ERROR:
          console.error('‚ùå WebSocket error:', message.message, message.code);
          break;
          
        case WS_MESSAGE_TYPES.CLOSE:
          console.log('üîå Server closing connection:', message.reason);
          break;
          
        default:
          console.log('‚ùì Unknown message type:', message.type);
      }
    } catch (error) {
      console.error('‚ùå Failed to parse WebSocket message:', error, event.data);
    }
  }, [onMessage, handlePong]);
  
  // ÈáçËøûÈÄªËæë
  const attemptReconnect = useCallback(() => {
    if (!settings.autoRetry || isManualDisconnectRef.current) {
      return;
    }

    if (reconnectAttempts >= WS_CONFIG.MAX_RECONNECT_ATTEMPTS) {
      console.error('‚ùå Max reconnect attempts reached');
      setConnectionStatus('error');
      return;
    }

    const delay = Math.min(
      WS_CONFIG.RECONNECT_INTERVAL * Math.pow(2, reconnectAttempts),
      30000 // ÊúÄÂ§ß30Áßí
    );

    console.log(`üîÑ Reconnecting in ${delay}ms (attempt ${reconnectAttempts + 1}/${WS_CONFIG.MAX_RECONNECT_ATTEMPTS})`);
    setConnectionStatus('reconnecting');

    reconnectTimeoutRef.current = setTimeout(() => {
      setReconnectAttempts(prev => prev + 1);
      // ‰ΩøÁî®refÈÅøÂÖçÂæ™ÁéØ‰æùËµñ
      if (connectFnRef.current) {
        connectFnRef.current(false);
      }
    }, delay);
  }, [settings.autoRetry, reconnectAttempts]);
  
  // ËøûÊé•WebSocketÁöÑÂÆûÁé∞
  const connect = useCallback(async (forceConnect = false) => {
    // Â¶ÇÊûúÊòØÊâãÂä®Êñ≠ÂºÄÁä∂ÊÄÅÔºå‰∏î‰∏çÊòØÂº∫Âà∂ËøûÊé•ÔºåÂàôÊãíÁªùËøûÊé•
    if (isManualDisconnectRef.current && !forceConnect) {
      console.log('üö´ Connection blocked: manual disconnect active');
      return;
    }

    // Èò≤Ê≠¢ÈáçÂ§çËøûÊé•
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      console.log('‚úÖ WebSocket already connected');
      return;
    }

    // Â¶ÇÊûúÊ≠£Âú®ËøûÊé•‰∏≠Ôºå‰∏çË¶ÅÈáçÂ§çËøûÊé•
    if (wsRef.current?.readyState === WebSocket.CONNECTING) {
      console.log('‚è≥ WebSocket connection already in progress');
      return;
    }

    // Âè™ÊúâÂú®Âº∫Âà∂ËøûÊé•Êó∂ÊâçÈáçÁΩÆÊâãÂä®Êñ≠ÂºÄÊ†áÂøó
    if (forceConnect) {
      isManualDisconnectRef.current = false;
    }
    setConnectionStatus('connecting');

    try {
      // Ëé∑Âèñtoken
      console.log('üîë Getting authentication token...');
      const token = await TokenManager.getToken();
      if (!token) {
        console.error('‚ùå No valid token available');
        setConnectionStatus('error');
        return;
      }

      console.log('‚úÖ Token obtained');

      // Áõ¥Êé•Âª∫Á´ãWebSocketËøûÊé•ÔºàÂèÇËÄÉÂéüÂûãÈÄªËæëÔºâ
      console.log('üîó Establishing WebSocket connection...');
      const wsUrl = `${WS_CONFIG.URL}?token=${encodeURIComponent(token)}`;
      wsRef.current = new WebSocket(wsUrl);

      // ËøûÊé•Ë∂ÖÊó∂Â§ÑÁêÜ
      const connectionTimeout = setTimeout(() => {
        if (wsRef.current?.readyState === WebSocket.CONNECTING) {
          console.error('‚ùå Connection timeout');
          wsRef.current.close();
          setConnectionStatus('error');
        }
      }, WS_CONFIG.CONNECTION_TIMEOUT);

      wsRef.current.onopen = () => {
        clearTimeout(connectionTimeout);
        console.log('‚úÖ WebSocket connected successfully');
        setConnectionStatus('connected');
        setReconnectAttempts(0);
        startHeartbeat();

        // ËøûÊé•ÊàêÂäüÂêéÁ´ãÂç≥ÂèëÈÄÅËÆ¢ÈòÖÔºàÂèÇËÄÉÂéüÂûãÈÄªËæëÔºâ
        console.log('üì° Sending subscription...');
        subscribe(settings.subscriptionConfig);
      };

      wsRef.current.onmessage = handleMessage;

      wsRef.current.onerror = (error) => {
        clearTimeout(connectionTimeout);
        console.error('‚ùå WebSocket error:', error);
        setConnectionStatus('error');
      };

      wsRef.current.onclose = (event) => {
        clearTimeout(connectionTimeout);
        clearTimers();

        console.log('üîå WebSocket closed:', {
          code: event.code,
          reason: event.reason,
          wasClean: event.wasClean,
          manual: isManualDisconnectRef.current
        });

        if (event.code === 1000 || isManualDisconnectRef.current) {
          // Ê≠£Â∏∏ÂÖ≥Èó≠ÊàñÊâãÂä®Êñ≠ÂºÄ
          setConnectionStatus('disconnected');
        } else {
          // ÂºÇÂ∏∏ÂÖ≥Èó≠ÔºåÂ∞ùËØïÈáçËøû
          setConnectionStatus('error');
          attemptReconnect();
        }
      };

    } catch (error) {
      console.error('‚ùå Failed to connect WebSocket:', error);
      setConnectionStatus('error');
      attemptReconnect();
    }
  }, [settings.subscriptionConfig, startHeartbeat, handleMessage, clearTimers, attemptReconnect]);

  // Â∞ÜconnectÂáΩÊï∞Â≠òÂÇ®Âú®ref‰∏≠ÔºåÈÅøÂÖçÂæ™ÁéØ‰æùËµñ
  useEffect(() => {
    connectFnRef.current = connect;
  }, [connect]);

  // Êñ≠ÂºÄËøûÊé• (‰ªÖÂ§ÑÁêÜÁúüÂÆûWebSocket)
  const disconnect = useCallback(() => {
    isManualDisconnectRef.current = true;
    clearTimers();

    // ÂÖ≥Èó≠ÁúüÂÆûWebSocketËøûÊé•
    if (wsRef.current) {
      wsRef.current.close(1000, 'Manual disconnect');
      wsRef.current = null;
    }

    setConnectionStatus('disconnected');
    setReconnectAttempts(0);
    console.log('üîå WebSocket disconnected');
  }, [clearTimers]);
  
  // ËÆ¢ÈòÖCA‰∫ã‰ª∂ (‰ªÖÁúüÂÆûWebSocket)
  const subscribe = useCallback((config?: SubscriptionConfig) => {
    const subscriptionConfig = config || settings.subscriptionConfig;

    if (wsRef.current?.readyState === WebSocket.OPEN) {
      sendMessage(subscriptionConfig);
      console.log('üì° WebSocket subscription:', subscriptionConfig);
    } else {
      console.warn('‚ö†Ô∏è Cannot subscribe: WebSocket not connected');
    }
  }, [settings.subscriptionConfig, sendMessage]);

  // ÂèñÊ∂àËÆ¢ÈòÖ (‰ªÖÁúüÂÆûWebSocket)
  const unsubscribe = useCallback(() => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      sendMessage({
        action: WS_MESSAGE_TYPES.UNSUBSCRIBE,
        event: 'realtime_ca'
      });
      console.log('üì° WebSocket unsubscribed');
    } else {
      console.warn('‚ö†Ô∏è Cannot unsubscribe: WebSocket not connected');
    }
  }, [sendMessage]);

  // Êõ¥Êñ∞ËÆ¢ÈòÖÈÖçÁΩÆ (‰ªÖÁúüÂÆûWebSocket)
  const updateSubscription = useCallback((config: SubscriptionConfig) => {
    if (isConnected) {
      subscribe(config);
    } else {
      console.warn('‚ö†Ô∏è Cannot update subscription: WebSocket not connected');
    }
  }, [isConnected, subscribe]);

  // Ê∏ÖÁêÜËµÑÊ∫ê
  useEffect(() => {
    return () => {
      clearTimers();
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, [clearTimers]);
  
  return {
    connectionStatus,
    isConnected,
    connect,
    disconnect,
    subscribe,
    unsubscribe,
    updateSubscription,
    reconnectAttempts
  };
}
